#!/usr/bin/python

useTidy=False

import sys
try:
	from xml.etree import ElementTree # for Python 2.5 users
except:
	from elementtree import ElementTree
try:
	import gdata
	import gdata.service
except:
	print >> sys.stderr, "Execution failed: gdata python module not found"
	sys.exit()
try:
	from PyQt4.QtCore import *
	from PyQt4.QtGui import *
except:
	print >> sys.stderr, "Execution failed: This script requires PyQt4 installed"
	sys.exit()

def buddyFor(widget, labelText) :
	label = QLabel(labelText)
	label.setBuddy(widget)
	return label

class LoginPage(QWizardPage) :
	def __init__(self, parent=None) :
		QWizardPage.__init__(self, parent)
		self.setTitle("Validation")
		self.setSubTitle("Introduce the login information for blogger.com.")

		self.server = QLineEdit(self)
		serverLabel = buddyFor(self.server,"Server")
		self.login = QLineEdit(self)
		loginLabel = buddyFor(self.login,"Login")
		self.passwd = QLineEdit(self)
		self.passwd.setEchoMode(self.passwd.Password)
		passwdLabel = buddyFor(self.passwd,"Password")
		self.errorMessage=QLabel("")

		layout = QGridLayout(self)
		self.setLayout(layout)
		layout.addWidget(serverLabel, 0, 0)
		layout.addWidget(self.server, 0, 1)
		layout.addWidget(loginLabel, 1, 0)
		layout.addWidget(self.login, 1, 1)
		layout.addWidget(passwdLabel, 2, 0)
		layout.addWidget(self.passwd, 2, 1)
		layout.addWidget(self.errorMessage, 3, 1)

		self.registerField("Server", self.server)
		self.registerField("Login", self.login)
		self.registerField("Password", self.passwd)

		self.server.setText("www.blogger.com")
		self.login.setText("yourname@gmail.com")
		self.passwd.setText("")
		self.setCommitPage(True)
		self.setButtonText(QWizard.CommitButton, "&Connect")

	def validatePage(self) :
		self.updateStatus("Validating user...", "blue")
		try :
			self.wizard().login(self.login.text(), self.passwd.text(), self.server.text())
		except Exception, error:
			self.updateStatus(error, "red")
			return False
		self.updateStatus("Logged in", "green")
		return True

	def updateStatus(self, message, color) :
		self.errorMessage.setText("<span style='color:%s'>%s</span>"%(color,message))
		# Force a widget update before continuing (proper way?)
		QApplication.sendPostedEvents()
		QApplication.processEvents()

class BlogSelectionPage(QWizardPage) :
	def __init__(self, parent=None) :
		QWizardPage.__init__(self, parent)
		self.setTitle("Blog selection")
		self.setSubTitle("Choose the blog you want to export")

		self.blogList = QListWidget(self)
		layout = QVBoxLayout(self)
		self.setLayout(layout)
		layout.addWidget(self.blogList)

		self.registerField("Blog*", self.blogList)

	def initializePage(self) :
		blogs = self.wizard().getBlogList()
		for title, url, id in blogs :
			print title, url, id
			item = QListWidgetItem(title)
			item.setData(Qt.UserRole, QVariant(id))
			self.blogList.addItem(item)

	def validatePage(self) :
		item = self.blogList.item(self.blogList.currentRow())
		self.wizard().blogId = str(item.data(Qt.UserRole).toString())
		print item.text(), self.wizard().blogId
		return True

class DirectoryPage(QWizardPage) :
	def __init__(self, parent=None) :
		QWizardPage.__init__(self, parent)
		self.setTitle("Destination directory")
		self.setSubTitle("Choose the directory where you want to dump the blog into")

		self.fileedit = QLineEdit(self)
		self.completer = QCompleter(self)
		self.completer.setModel(QDirModel(self.completer));
		self.fileedit.setCompleter(self.completer);
		self.pushButton = QPushButton(self)
		self.pushButton.setText('&Choose')
		self.error = QLabel(self)
		layoutV = QVBoxLayout(self)
		layout = QHBoxLayout(self)
		layoutV.addLayout(layout)
		layoutV.addWidget(self.error)
		layout.addWidget(self.fileedit)
		layout.addWidget(self.pushButton)
		self.setLayout(layoutV)

		self.connect(self.pushButton,SIGNAL("clicked()"),
			self.chooseDirectory)
		self.registerField("Directory*", self.fileedit)

		self.setCommitPage(True)
		self.setButtonText(QWizard.CommitButton, "&Export")


	def chooseDirectory(self) :
		directory = QFileDialog.getExistingDirectory(self, "Choose a directory")
		if directory : self.fileedit.setText(directory)
		pass	

	def initializePage(self) :
		self.fileedit.setText(self.wizard().targetDir)

	def isComplete(self) :
		from os.path import isdir
		from os import access, W_OK
		targetdir = str(self.fileedit.text())
		self.emit(SIGNAL("isComplete()"))
		if not isdir(targetdir):
			self.error.setText("<span style='color:red'>Directory does not exist</span>")
			return False
		if not access(targetdir, W_OK) :
			self.error.setText("<span style='color:red'>Directory can not be written</span>")
			return False
		self.error.setText("")
		return True

	def validatePage(self) :
		targetdir = str(self.fileedit.text())
		self.wizard().targetDir = targetdir
		return True

class RunPage(QWizardPage) :
	def __init__(self, parent=None) :
		QWizardPage.__init__(self, parent)
		self.setTitle("Execution")
		self.setSubTitle("Exporting the blog into your file system")

		self.log = QTextEdit(self)
		self.log.setReadOnly(True)
		self.log.setText("Exporting...")

		layout = QHBoxLayout(self)
		self.setLayout(layout)
		layout.addWidget(self.log)

	def isComplete(self) :
		for action in self.wizard().dump(stepped=True) :
			print "Execution", action
			self.log.append(action)
			QApplication.sendPostedEvents()
			QApplication.processEvents()
		return True


	def initializePage(self) :
		pass

	

class BloggerImportWizard (QWizard) :

	def login(self, user, password, server) :
		self.service = gdata.service.GDataService(user, password)
		self.service.source = 'WiKo'
		self.service.service = 'blogger'
		self.service.server = unicode(server)
		self.service.ProgrammaticLogin()

	def getBlogList(self) :
		query = gdata.service.Query()
		query.feed = '/feeds/default/blogs'
		feed = self.service.Get(query.ToUri())
		blogs = [ 
			(
				entry.title.text, 
				entry.GetSelfLink().href,
				entry.GetSelfLink().href.split('/')[-1],
			) for entry in feed.entry ]
		return blogs

	def __init__(self, parent=None) :
		QWizard.__init__(self)
		self.setWindowTitle("Blogger.com to WiKo")
		self.setPixmap(self.LogoPixmap, QPixmap("blogger_logo_small.png"))
		self.setPixmap(self.WatermarkPixmap, QPixmap("wikologo.png"))
		self.blogId = None
		self.service = None
		self.targetDir = ""

		page = QWizardPage(self)
		page.setTitle("Introduction")
		layout = QVBoxLayout()
		page.setLayout(layout);
		label = QLabel(
			"""<p>This wizard will help you export your blog at blogger.com
				into a set of files which are able to be processed by WiKo.
				Note that once you export the files, you can still keep them
				up to date.</p>
				<p>Visit <a href='http://wiko.sourceforge.net'>WiKo web page</a>
				for further information.</p>
			""")
		label.setWordWrap(True)
		layout.addWidget(label)

		self.introPage  = self.addPage(page)
		self.loginPage  = self.addPage(LoginPage(self))
		self.blogPage   = self.addPage(BlogSelectionPage(self))
		self.targetPage = self.addPage(DirectoryPage(self))
		self.runPage = self.addPage(RunPage(self))

	def dump(self, stepped=False) :
		if stepped :
			yield "Fetching blog %s"%self.blogId
		feed = self.service.GetFeed('/feeds/%s/posts/default' % self.blogId )
		print "Generator:", feed.generator.text
		print "Category:", [category.text for category in feed.category]
		print "Contributor:", [contributor.text for contributor in feed.contributor]
		print "Id:", feed.id.text
		if stepped : yield "Title: " + (feed.title and feed.title.text)
		if stepped and feed.subtitle: yield "Subtitle: " + feed.subtitle.text
		print "Link:", [(link.href, dir(link)) for link in feed.link]
		print "Updated:", feed.updated.text
		import string
		import os.path
		for entry in feed.entry:
			title = entry.title.text or "No title"
			id = entry.id.text.split("-")[-1]
			filename = "blog-"+id+"-"+title.title().translate(string.maketrans("",""),"! ,./:?")
			filename += ".wiki" # if entry.content.type is not "html" else ".html"
			fullfilename = os.path.join(self.targetDir,filename)
			if stepped: yield "Generating " + filename
			import codecs
			blogfile=codecs.open(fullfilename,'w','utf-8')
			print >> blogfile, "@id:", id
			
			print >> blogfile, "@author:", (", ".join([author.name.text for author in entry.author]))
#			print >> blogfile, "@email:", (", ".join([author.email.text for author in entry.author if author.email]))
#			print >> blogfile, "@authoruri:", (", ".join([author.uri.href for author in entry.author if author.uri]))
#			print >> blogfile, "@contributor:", (", ".join([contrib.name.text for contrib in entry.contributor]))
#			print >> blogfile, "@source:", entry.source and entry.source.text
			print >> blogfile, "@title: " + entry.title.text
			print >> blogfile, "@updated:", entry.updated.text
			print >> blogfile, "@published:", entry.published.text
			print >> blogfile, "@category:", (", ".join([category.term for category in entry.category]))
			print >> blogfile
			content = self.wikify(entry.content.text)
			print >> blogfile, content
#			self.getComments(entry.id.text.split("-")[-1])
#			print dir(entry)
		print self.getComments()
	def wikify(self, content) :
		if useTidy:
			# TODO: This crashes (core dump!) for some files
			import tidy
			tidyOptions = dict(
				output_xhtml=1, 
				show_body_only=1,
				indent=1,
				tidy_mark=0,
				)
			tidy.parseString(content+"\n", **tidyOptions)
		import re
		substitutions = [
			(r'<a\s+href\s*=\s*"([^"]+)">([^<]+)\s*<\s*/\s*a\s*>', r"[[\1 \2]]"),
			(r"<a\s+href\s*=\s*'([^']+)'>([^<]+)\s*<\s*/\s*a\s*>", r"[[\1 \2]]"),
			(r'<br />', "\n"),
			('<p>', "\n\n"),
		]
		substitutions = [(re.compile(old), new) for old, new in substitutions]
		for old, new in substitutions :
			content = old.sub(new, content)
		return content

	def getComments(self, postId=None) :
		# Build comment feed URI and request comments on the specified post
		feed_url = '/feeds/' + self.blogId
		feed_url+= "" if postId is None else '/' + postId
		feed_url+='/comments/default'
		feed = self.service.Get(feed_url)
		return [ dict(
			id = entry.id.text.split("-")[-1],
			title = entry.title.text,
			updated = entry.updated.text,
			content = self.wikify(entry.content.text),
			author = ",".join([author.name.text for author in entry.author])
			) for entry in feed.entry ]

def main():
	app=QApplication(sys.argv)
	wizard = BloggerImportWizard()
	wizard.targetDir="blogdump/"
	if wizard.exec_() != QDialog.Accepted :
		exit(-1)
	exit(0)

if __name__ == '__main__':
	main()


